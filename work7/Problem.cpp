Problem A
开放定址法处理冲突
时限：1000ms 内存限制：10000K 总时限：3000ms
描述：


选取哈希函数H(k)=(3k) MOD 11。用开放定址法处理冲突，其中di=i((7k) MOD 10+1)（i=1,2,3...）。
在0~10的散列地址空间中给出的关键字序列构造哈希表，并统计出查找这些关键字的实际比较次数，
输出平均查找长度。

输入：


关键字序列（关键字总数小于11）

输出：


平均查找长度（保留小数点后三位）

输入样例：


22 41 53 46 30 13 1 67
输出样例：


2.125

0  1  2  3  4  5  6  7  8  9  10 
22 1  41 30 67 53 46 13
22 30 41 13    53 46 1


Problem B
判定给定二叉树是否为二叉排序树
时限：1000ms 内存限制：10000K 总时限：3000ms
描述：


试写一个判定给定二叉树是否为二叉排序树的程序，设此二叉树以二叉链表做存储结构，且结点的关键字均不同

输入：


输入一个二叉树的先序序列，若某个节点没有左孩子（右孩子），则左孩子（右孩子）用0表示

输出：


输出二叉树的中序遍历序列，并判断该二叉树是否为二叉排序树，若是，则输出“It is an BinaryOrderTree!”，否则输出“It is not an BinaryOrderTree!”

输入样例：


5 3 2 0 0 4 0 0 7 6 0 0 8 0 0
输出样例：


2
3
4
5
6
7
8
It is an BinaryOrderTree!



Problem C
二叉排序树的查找、删除、插入
时限：1000ms 内存限制：10000K 总时限：3000ms
描述：


假设二叉排序树以后继线索链表作存储结构，实现以下功能：
1、编写出该二叉排序树中所有大于a且小于b的关键字的算法。
2、编写在二叉排序树中删除一个关键字的算法。
3、在删除后的二叉排序树中插入一个关键字。


输入：


1、输入二叉排序树的关键字个数
2、乱序输入二叉排序树的关键字（可重复，若重复，则只计入一次）
3、输入a、b的值（a<b）
4、输入要删除的关键字的值
5、输入要插入的关键字的值

输出：


1、中序遍历输出原始二叉排序树
2、输出符合“大于a，小于b”这一条件的所有关键字的值。若不存在，则输出“NOT FOUND”
3、中序遍历输出删除节点后的二叉排序树。若要删除的节点不存在，则仍输出原始二叉树的中序遍历结果。
4、中序遍历输出插入节点后的二叉排序树。若要插入的节点已存在，则仍输出原始二叉树的中序遍历结果。


输入样例：


5
2 5 3 6 10
7 9
3
8
输出样例：


2 3 5 6 10
NOT FOUND
2 5 6 10
2 5 6 8 10

Problem D
合并二叉排序树
时限：1000ms 内存限制：10000K 总时限：3000ms
描述：


先序建立两棵二叉排序树，采用二叉链表结构存储，将这两棵二叉排序树合并成一棵新的二叉排序树，并按照中序序列输出合并后的二叉排序树。

输入：


输入两行先序遍历的整型数据，并以此分别建立两棵二叉排序树（其中整型数据必须为大于等于零的整数）。
如输入某二叉排序树的先序序列为：12 8 4 -1 -1 10 -1 -1 16 13 -1 -1 18 -1 -1（其中-1代表空树）。

输出：


按照中序序列输出合并后的二叉排序树（输出结果后换行）。

输入样例：


12 8 4 -1 -1 10 -1 -1 16 13 -1 -1 18 -1 -1
17 6 2 -1 -1 9 -1 -1 24 19 -1 -1 26 -1 -1
输出样例：


2 4 6 8 9 10 12 13 16 17 18 19 24 26


